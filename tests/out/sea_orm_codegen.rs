//! Generated by sea-orm-dbml 0.1.0-beta.2

pub mod cake {
	use sea_orm::entity::prelude::*;

	#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
	#[sea_orm(table_name = "cake", schema_name = "public")]
	pub struct Model {
		#[sea_orm(column_type = "Integer", primary_key)]
		pub id: i32,
		#[sea_orm(column_type = "Text", nullable)]
		pub name: Option<String>,
	}

	#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
	pub enum Relation {
		#[sea_orm(has_many = "super::cake_filling::Entity")]
		CakeFilling,
		#[sea_orm(has_many = "super::fruit::Entity")]
		Fruit,
	}

	impl Related<super::cake_filling::Entity> for Entity {
		fn to() -> RelationDef {
			Relation::CakeFilling.def()
		}
	}

	impl Related<super::fruit::Entity> for Entity {
		fn to() -> RelationDef {
			Relation::Fruit.def()
		}
	}

	impl ActiveModelBehavior for ActiveModel {}
}

pub mod vendor {
	use sea_orm::entity::prelude::*;

	#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
	#[sea_orm(table_name = "vendor", schema_name = "public")]
	pub struct Model {
		#[sea_orm(column_type = "Integer", primary_key)]
		pub id: i32,
		#[sea_orm(column_type = "String(None)")]
		pub name: String,
		#[sea_orm(column_type = "Integer", nullable)]
		pub fruit_id: Option<i32>,
	}

	#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
	pub enum Relation {
		#[sea_orm(belongs_to = "super::fruit::Entity", from = "Column::FruitId", to = "super::fruit::Column::Id")]
		Fruit,
	}

	impl Related<super::fruit::Entity> for Entity {
		fn to() -> RelationDef {
			Relation::Fruit.def()
		}
	}

	impl ActiveModelBehavior for ActiveModel {}
}

pub mod fruit {
	use sea_orm::entity::prelude::*;

	#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
	#[sea_orm(table_name = "fruit", schema_name = "public")]
	pub struct Model {
		#[sea_orm(column_type = "Integer", primary_key)]
		pub id: i32,
		#[sea_orm(column_type = "String(None)")]
		pub name: String,
		#[sea_orm(column_type = "Integer", nullable)]
		pub cake_id: Option<i32>,
	}

	#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
	pub enum Relation {
		#[sea_orm(belongs_to = "super::cake::Entity", from = "Column::CakeId", to = "super::cake::Column::Id")]
		Cake,
		#[sea_orm(has_many = "super::vendor::Entity")]
		Vendor,
	}

	impl Related<super::cake::Entity> for Entity {
		fn to() -> RelationDef {
			Relation::Cake.def()
		}
	}

	impl Related<super::vendor::Entity> for Entity {
		fn to() -> RelationDef {
			Relation::Vendor.def()
		}
	}

	impl ActiveModelBehavior for ActiveModel {}
}

pub mod filling {
	use sea_orm::entity::prelude::*;

	#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
	#[sea_orm(table_name = "filling", schema_name = "public")]
	pub struct Model {
		#[sea_orm(column_type = "Integer", primary_key)]
		pub id: i32,
		#[sea_orm(column_type = "String(None)")]
		pub name: String,
	}

	#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
	pub enum Relation {
		#[sea_orm(has_many = "super::cake_filling::Entity")]
		CakeFilling,
	}

	impl Related<super::cake_filling::Entity> for Entity {
		fn to() -> RelationDef {
			Relation::CakeFilling.def()
		}
	}

	impl ActiveModelBehavior for ActiveModel {}
}

pub mod cake_filling {
	use sea_orm::entity::prelude::*;

	#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
	#[sea_orm(table_name = "cake_filling", schema_name = "public")]
	pub struct Model {
		#[sea_orm(column_type = "Integer", primary_key)]
		pub cake_id: i32,
		#[sea_orm(column_type = "Integer", primary_key)]
		pub filling_id: i32,
	}

	#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
	pub enum Relation {
		#[sea_orm(belongs_to = "super::cake::Entity", from = "Column::CakeId", to = "super::cake::Column::Id", on_delete = "Cascade", on_update = "Cascade")]
		Cake,
		#[sea_orm(belongs_to = "super::filling::Entity", from = "Column::FillingId", to = "super::filling::Column::Id", on_delete = "Cascade", on_update = "Cascade")]
		Filling,
	}

	impl Related<super::cake::Entity> for Entity {
		fn to() -> RelationDef {
			Relation::Cake.def()
		}
	}

	impl Related<super::filling::Entity> for Entity {
		fn to() -> RelationDef {
			Relation::Filling.def()
		}
	}

	impl ActiveModelBehavior for ActiveModel {}
}
